C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.l
                    -st) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include"i2c.h"
   2          #include"oledchar.h"
   3          #include"intrins.h"
   4          #include"STC12C5A.h"
   5          
   6          #define uchar unsigned char
   7          #define uint  unsigned int
   8          
   9          uchar PuZh[36] = "收到";
  10          
  11          
  12          //--定义使用的IO--//
  13           sbit Trig_P = P1^6;    // 超声波模块的Trig管脚
  14           sbit Echo_P = P1^7;    // 超声波模块的Echo管脚
  15           sbit PWM = P2^5;   //舵机的pwm引脚
  16          
  17           sbit A1 = P0^0;      //左上角电机
  18           sbit A2 = P0^1;
  19           sbit B1 = P0^2;      //右上角电机
  20           sbit B2 = P0^3;
  21           sbit C1 = P0^4;      //左下角电机
  22           sbit C2 = P0^5;
  23           sbit D1 = P0^6;      //右下角电机
  24           sbit D2 = P0^7;  
  25           sbit lse1  = P1^0;//右边外边红外传感器的数据口
  26           sbit lse2  = P1^1;//右边里边红外传感器的数据口 
  27           sbit lse3  = P1^2;//左边里边红外传感器的数据口
  28           sbit lse4  = P1^3;//左边外边红外传感器的数据口
  29           
  30           
  31           //--声明避障全局函数--// 
  32          void bizhang ();
  33          void judge ();
  34          void Delay80ms();
  35          void bizhangrun ();
  36          void bizhangbackrun ();
  37          void bizhangleftrun ();
  38          void bizhangrightrun ();
  39          void duoji_Init();
  40           //--声明oled全局函数--// 
  41           void oleddisplay (unsigned char oleddisplaymode);
  42           void DelayMs(unsigned int time);
  43           void detect ();
  44           
  45          //--声明wifi全局函数--//   
  46           void UsartConfiguration();
  47           void Delay_1ms(uint i);
  48           void pwmdelay (unsigned int t);
  49          
  50          //--声明寻迹全局函数--//
  51          void pwmdelay(unsigned int t); 
  52          void run(void);
  53          void stop(void);
  54          void leftrun(void);
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 2   

  55          void rightrun(void);
  56          void xunji();
  57          void Delay350ms();
  58          
  59          //定义wifi全局变量//
  60          unsigned int t;
  61          unsigned int wifispeed=1000;       //WiFi模式速度      范围（500-2000）
  62          unsigned int wifiturningspeed=800 ;  //WiFi模式转弯速度    范围（800-2000）
  63          unsigned char wifisrunningtime=70;   //此处决定wifi模式直线运行时长
  64          unsigned char wifiturningtime =40;        //此处决定wifi模式转弯运行时长
  65          unsigned int wificircle=2000;    //决定wifi模式pwm周期
  66          unsigned char receive_data;
  67          
  68          //定义寻迹全局变量//
  69           unsigned char flag;
  70           unsigned int turningspeed = 2000;  //寻迹转弯速度     范围（300-2000）
  71           unsigned int speed=800;       //寻迹直线速度     范围（300-2000）
  72           unsigned int turningtime=4;   //寻迹转弯运行时长
  73           unsigned int srunnningtime=10;   //寻迹直线运行时长 
  74           unsigned int circle=2000;        //决定周期
  75           unsigned char runtimes = 0;
  76          
  77          
  78          //定义oled全局变量
  79          unsigned char displaymode;
  80          unsigned char percent,operate;
  81          double fenzi,fenmu;
  82          
  83          
  84          //定义避障全局变量
  85          unsigned int bizhangspeed = 1300;
  86          unsigned char bizhangrunnningtime = 15;
  87          unsigned char bizhangturningtime = 10;
  88          unsigned int bizhangturningspeed = 2000;
  89          unsigned int bizhangcircle = 2000;
  90          unsigned char distance,leftdistance,rightdistance,location,judgement;
  91          double count = 0,angle;
  92          extern unsigned int GetDistance(void);
  93          unsigned int GetDistance(void)
  94          {
  95   1        float gSpeed=0.03460000;            
  96   1        unsigned int ss1;     
  97   1        unsigned int ss;          // 用于记录测得的距离整数部分
  98   1      
  99   1        TH0=0;
 100   1        TL0=0;
 101   1      
 102   1        Trig_P=1;         // 给超声波模块一个开始脉冲
 103   1        DelayMs(1);
 104   1        Trig_P=0;
 105   1      
 106   1        while(!Echo_P);   // 等待超声波模块的返回脉冲
 107   1        TR0=1;            // 启动定时器，开始计时
 108   1        while(Echo_P);    // 等待超声波模块的返回脉冲结束
 109   1        TR0=0;            // 停止定时器，停止计时
 110   1      
 111   1        ss = ((TH0*256+TL0)*gSpeed)/2;    // 距离cm=（时间us * 速度cm/us）/2
 112   1          ss1 = ((TH0*256+TL0)*gSpeed*10)/2;
 113   1        ss1 = (ss1 - ss*10) * 100;
 114   1      
 115   1        if(ss>999)        // 把检测结果限制999厘米内
 116   1          ss=999;
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 3   

 117   1        
 118   1        return ss;
 119   1      }
 120          
 121          
 122          
 123          
 124          
 125          //以下为代码部分------------------------------------------------------------------------------------------
             -----------------
 126          
 127          
 128          void oleddisplay (unsigned char oleddisplaymode)
 129          {
 130   1      unsigned char ge =0,shi=0 ,bai=0,i,j,jl1=0,jl2=0,jl3=0,cz1=0,cz2=0;      //(i为元素个数j为数据类型)
 131   1         if (oleddisplaymode == 1) //遥控显示模式
 132   1            { 
 133   2              
 134   2        i=0;  while (1)//第一行固定显示   模式：手机遥控。-
 135   2        {
 136   3          oled_put_char_16x16(i,0,1);   //决定放的位置和属性(x轴,y轴,属性)(0为英文或数字1为中文)
 137   3          
 138   3          j=0; while (1)
 139   3          {
 140   4            oled_Write_data(zifu[i][j]);  // 决定放的东西
 141   4            j= j+1; 
 142   4          if (j >= 32){break;}
 143   4          }
 144   3          
 145   3      i = i+1;
 146   3      if (i >= 8){break;}   
 147   3        }
 148   2        
 149   2        for(i=0;i<=4;i++)//第二行固定显示   运行时速：   %  -  三位空余
 150   2        {
 151   3          oled_put_char_16x16(i,1,1);
 152   3          for(j=0;j<32;j++)
 153   3          {
 154   4            oled_Write_data(zifu[i+8][j]);  
 155   4          }     
 156   3        }
 157   2        
 158   2      oled_put_char_16x16(13,1,0);  //百分号
 159   2          for(j=0;j<16;j++)
 160   2          {
 161   3            oled_Write_data(number[10][j]);  
 162   3          }
 163   2          
 164   2        for(i=0;i<=4;i++)//第三行固定显示   遥控操作：      -   六位空余
 165   2        {
 166   3          oled_put_char_16x16(i,2,1);
 167   3          for(j=0;j<32;j++)
 168   3          {
 169   4            oled_Write_data(zifu[i+13][j]);  
 170   4          } 
 171   3      
 172   3        }
 173   2      
 174   2      
 175   2        for(i=0;i<=4;i++)//第四行固定显示   障碍物距离    CM-  四位空余
 176   2        {
 177   3          oled_put_char_16x16(i,3,1);
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 4   

 178   3          for(j=0;j<32;j++)
 179   3          {
 180   4            oled_Write_data(zifu[i+18][j]);  
 181   4          } 
 182   3        }
 183   2        
 184   2        oled_put_char_16x16(14,3,0);    //C
 185   2          for(j=0;j<16;j++)
 186   2          {
 187   3            oled_Write_data(number[11][j]);  
 188   3          } 
 189   2        oled_put_char_16x16(15,3,0);   //M
 190   2          for(j=0;j<16;j++)
 191   2          {
 192   3            oled_Write_data(number[12][j]);  
 193   3          } 
 194   2          
 195   2        fenzi = wifispeed;fenmu = wificircle;
 196   2      percent =  (fenzi/fenmu)*100;
 197   2          
 198   2        displaymode = 4;
 199   2          } 
 200   1      
 201   1        if (oleddisplaymode == 2)//寻迹显示模式
 202   1      {
 203   2        for(i=0;i<=7;i++)//第一行固定显示   模式：自动寻迹。-
 204   2        {
 205   3          oled_put_char_16x16(i,0,1);   //决定放的位置和属性(x轴,y轴,属性)(0为英文或数字1为中文)
 206   3          for(j=0;j<32;j++)
 207   3          {
 208   4            oled_Write_data(zifu[i+23][j]);  // 决定放的东西
 209   4          }   
 210   3        }
 211   2        
 212   2        for(i=0;i<=4;i++)//第二行固定显示   运行时速：   %  -  三位空余
 213   2        {
 214   3          oled_put_char_16x16(i,1,1);
 215   3          for(j=0;j<32;j++)
 216   3          {
 217   4            oled_Write_data(zifu[i+8][j]);  
 218   4          }     
 219   3        }
 220   2        
 221   2      oled_put_char_16x16(13,1,0);  //百分号
 222   2          for(j=0;j<16;j++)
 223   2          {
 224   3            oled_Write_data(number[10][j]);  
 225   3          }
 226   2          
 227   2      
 228   2        
 229   2        for(i=0;i<=4;i++)//第三行固定显示   寻迹操作：      -   六位空余
 230   2        {
 231   3          oled_put_char_16x16(i,2,1);
 232   3          for(j=0;j<32;j++)
 233   3          {
 234   4            oled_Write_data(zifu[i+31][j]);  
 235   4          } 
 236   3      
 237   3        }
 238   2      
 239   2      
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 5   

 240   2        for(i=0;i<=4;i++)//第四行固定显示   障碍物距离    CM-  四位空余
 241   2        {
 242   3          oled_put_char_16x16(i,3,1);
 243   3          for(j=0;j<32;j++)
 244   3          {
 245   4            oled_Write_data(zifu[i+18][j]);  
 246   4          } 
 247   3        }
 248   2        
 249   2        oled_put_char_16x16(14,3,0);    //C
 250   2          for(j=0;j<16;j++)
 251   2          {
 252   3            oled_Write_data(number[11][j]);  
 253   3          } 
 254   2        oled_put_char_16x16(15,3,0);   //M
 255   2          for(j=0;j<16;j++)
 256   2          {
 257   3            oled_Write_data(number[12][j]);  
 258   3          } 
 259   2      
 260   2      fenzi = speed;fenmu = circle;
 261   2      percent =  (fenzi/fenmu)*100;   
 262   2          
 263   2        displaymode = 4;
 264   2          } 
 265   1      
 266   1      
 267   1          
 268   1       
 269   1       if (oleddisplaymode == 3)//避障显示模式
 270   1       {
 271   2        for(i=0;i<=7;i++)//第一行固定显示   模式：自动避障。-
 272   2        {
 273   3          oled_put_char_16x16(i,0,1);   //决定放的位置和属性(x轴,y轴,属性)(0为英文或数字1为中文)
 274   3          for(j=0;j<32;j++)
 275   3          {
 276   4            oled_Write_data(zifu[i+36][j]);  // 决定放的东西
 277   4          }   
 278   3        }
 279   2        
 280   2        for(i=0;i<=4;i++)//第二行固定显示   运行时速：   %  -  三位空余
 281   2        {
 282   3          oled_put_char_16x16(i,1,1);
 283   3          for(j=0;j<32;j++)
 284   3          {
 285   4            oled_Write_data(zifu[i+8][j]);  
 286   4          }     
 287   3        }
 288   2        
 289   2      oled_put_char_16x16(13,1,0);  //百分号
 290   2          for(j=0;j<16;j++)
 291   2          {
 292   3            oled_Write_data(number[10][j]);  
 293   3          }
 294   2        
 295   2        for(i=0;i<=4;i++)//第三行固定显示   避障操作：      -   六位空余
 296   2        {
 297   3          oled_put_char_16x16(i,2,1);
 298   3          for(j=0;j<32;j++)
 299   3          {
 300   4            oled_Write_data(zifu[i+44][j]);  
 301   4          } 
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 6   

 302   3      
 303   3        }
 304   2      
 305   2      
 306   2        for(i=0;i<=4;i++)//第四行固定显示   障碍物距离    CM-  四位空余
 307   2        {
 308   3          oled_put_char_16x16(i,3,1);
 309   3          for(j=0;j<32;j++)
 310   3          {
 311   4            oled_Write_data(zifu[i+18][j]);  
 312   4          } 
 313   3        }
 314   2        
 315   2        oled_put_char_16x16(14,3,0);    //C
 316   2          for(j=0;j<16;j++)
 317   2          {
 318   3            oled_Write_data(number[11][j]);  
 319   3          } 
 320   2        oled_put_char_16x16(15,3,0);   //M
 321   2          for(j=0;j<16;j++)
 322   2          {
 323   3            oled_Write_data(number[12][j]);  
 324   3          } 
 325   2        displaymode = 4;
 326   2        }
 327   1          
 328   1      
 329   1      
 330   1       if (oleddisplaymode == 4)  //变量显示部分
 331   1       { 
 332   2      
 333   2         
 334   2      bai = percent/100;
 335   2      shi = percent/10-bai*10;
 336   2      ge  = percent%10;
 337   2      jl1 = distance/100;
 338   2      jl2 = distance/10-jl1*10;
 339   2      jl3 = distance%10;
 340   2      cz1 = operate/10;     //operate 前进1 后退23 左转45 右转67 静止89
 341   2      cz2 = operate%10;  
 342   2        
 343   2      if (percent >= 100)
 344   2      { 
 345   3          oled_put_char_16x16(10,1,0);  //百分比百位
 346   3        j=0; while (1){
 347   4           oled_Write_data(number[bai][j]);  
 348   4        j=j+1;if (j >= 16){break;}}
 349   3      
 350   3          oled_put_char_16x16(11,1,0);  //百分比十位
 351   3        j=0; while (1){
 352   4            oled_Write_data(number[shi][j]);  
 353   4        j=j+1;if (j >= 16){break;}}
 354   3        
 355   3          oled_put_char_16x16(12,1,0);  //百分比个位
 356   3        j=0; while (1){
 357   4            oled_Write_data(number[ge][j]);  
 358   4        j=j+1;if (j >= 16){break;}}
 359   3      }
 360   2      
 361   2      if (percent < 100 && percent >= 10)
 362   2      { 
 363   3          oled_put_char_16x16(10,1,0);  //百分比百位
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 7   

 364   3        j=0; while (1){
 365   4           oled_Write_data(number[13][j]);  
 366   4        j=j+1;if (j >= 16){break;}}
 367   3      
 368   3          oled_put_char_16x16(11,1,0);  //百分比十位
 369   3        j=0; while (1){
 370   4            oled_Write_data(number[shi][j]);  
 371   4        j=j+1;if (j >= 16){break;}}
 372   3        
 373   3          oled_put_char_16x16(12,1,0);  //百分比个位
 374   3        j=0; while (1){
 375   4            oled_Write_data(number[ge][j]);  
 376   4        j=j+1;if (j >= 16){break;}}
 377   3      }
 378   2      
 379   2      if (percent < 10 && percent >= 0)
 380   2      { 
 381   3          oled_put_char_16x16(10,1,0);  //百分比百位
 382   3        j=0; while (1){
 383   4           oled_Write_data(number[13][j]);  
 384   4        j=j+1;if (j >= 16){break;}}
 385   3      
 386   3          oled_put_char_16x16(11,1,0);  //百分比十位
 387   3        j=0; while (1){
 388   4            oled_Write_data(number[13][j]);  
 389   4        j=j+1;if (j >= 16){break;}}
 390   3        
 391   3          oled_put_char_16x16(12,1,0);  //百分比个位
 392   3        j=0; while (1){
 393   4            oled_Write_data(number[ge][j]);  
 394   4        j=j+1;if (j >= 16){break;}}
 395   3      }
 396   2      
 397   2        
 398   2      
 399   2        oled_put_char_16x16(5,2,1);     //操作第一位
 400   2        j=0; while (1){
 401   3            oled_Write_data(caozuo[cz1][j]);  
 402   3        j=j+1;if (j >= 32){break;}}
 403   2        
 404   2          oled_put_char_16x16(6,2,1);    //操作第二位
 405   2        j=0; while (1){
 406   3            oled_Write_data(caozuo[cz2][j]);  
 407   3        j=j+1;if (j >= 32){break;}}
 408   2        
 409   2      
 410   2        
 411   2        
 412   2        
 413   2        
 414   2        if (distance >= 100)
 415   2      { 
 416   3          oled_put_char_16x16(11,3,0);  //距离百位
 417   3        j=0; while (1){
 418   4            oled_Write_data(number[jl1][j]);  
 419   4        j=j+1;if (j >= 16){break;}}
 420   3        
 421   3        
 422   3          oled_put_char_16x16(12,3,0);  //距离十位
 423   3        j=0; while (1){
 424   4            oled_Write_data(number[jl2][j]);  
 425   4        j=j+1;if (j >= 16){break;}}
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 8   

 426   3      
 427   3      
 428   3          oled_put_char_16x16(13,3,0);  //距离个位
 429   3        j=0; while (1){
 430   4            oled_Write_data(number[jl3][j]);  
 431   4        j=j+1;if (j >= 16){break;}}
 432   3      } 
 433   2        
 434   2        
 435   2        if (distance >= 10 && distance < 100)
 436   2      { 
 437   3          oled_put_char_16x16(11,3,0);  //距离百位
 438   3        j=0; while (1){
 439   4            oled_Write_data(number[13][j]);  
 440   4        j=j+1;if (j >= 16){break;}}
 441   3        
 442   3        
 443   3          oled_put_char_16x16(12,3,0);  //距离十位
 444   3        j=0; while (1){
 445   4            oled_Write_data(number[jl2][j]);  
 446   4        j=j+1;if (j >= 16){break;}}
 447   3      
 448   3      
 449   3          oled_put_char_16x16(13,3,0);  //距离个位
 450   3        j=0; while (1){
 451   4            oled_Write_data(number[jl3][j]);  
 452   4        j=j+1;if (j >= 16){break;}}
 453   3      }
 454   2      
 455   2      
 456   2      if (distance < 10 && distance >0)
 457   2      { 
 458   3          oled_put_char_16x16(11,3,0);  //距离百位
 459   3        j=0; while (1){
 460   4            oled_Write_data(number[13][j]);  
 461   4        j=j+1;if (j >= 16){break;}}
 462   3        
 463   3        
 464   3          oled_put_char_16x16(12,3,0);  //距离十位
 465   3        j=0; while (1){
 466   4            oled_Write_data(number[13][j]);  
 467   4        j=j+1;if (j >= 16){break;}}
 468   3      
 469   3      
 470   3          oled_put_char_16x16(13,3,0);  //距离个位
 471   3        j=0; while (1){
 472   4            oled_Write_data(number[jl3][j]);  
 473   4        j=j+1;if (j >= 16){break;}}
 474   3      }
 475   2      
 476   2         }  
 477   1        
 478   1      }
 479          
 480          
 481          //以下为寻迹模式代码--------------------------------------------------------------------------------------
             ----------------- 
 482          void pwmdelay(unsigned int t)
 483          {
 484   1      while (t--);
 485   1      }
 486          
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 9   

 487          
 488          
 489          void run(void)
 490          { 
 491   1        operate = 1;
 492   1        detect ();
 493   1        fenzi = speed;fenmu = circle;
 494   1      percent =  (fenzi/fenmu)*100;
 495   1      for (t=0;t<srunnningtime;t++) 
 496   1      {
 497   2        
 498   2        if((lse1==1)||(lse2==1)||(lse3==1)||(lse4==1)||(distance <= 15))
 499   2        { A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0;break;}
 500   2          A1 = 1,A2 = 0,B1 = 1,B2 = 0,C1 = 1,C2 = 0,D1 = 1,D2 = 0;
 501   2          pwmdelay(speed);
 502   2          A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
 503   2          pwmdelay(circle-speed);
 504   2        if((lse1==1)||(lse2==1)||(lse3==1)||(lse4==1)||(distance <= 15))
 505   2        { A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0;break;}
 506   2        
 507   2        
 508   2      
 509   2      }
 510   1      }
 511          
 512          
 513          
 514          void leftrun(void)
 515          { 
 516   1        operate = 67;
 517   1        fenzi = speed;fenmu = circle;
 518   1      percent =  (fenzi/fenmu)*100;
 519   1      for (t=0;t<turningtime;t++) 
 520   1      {
 521   2          A1 = 1,A2 = 0,B1 = 0,B2 = 1,C1 = 1,C2 = 0,D1 = 0,D2 = 1;  
 522   2          pwmdelay(turningspeed);
 523   2          A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
 524   2          pwmdelay(circle-turningspeed);
 525   2      }
 526   1      
 527   1      }
 528          
 529          void rightrun(void)
 530          { 
 531   1        operate = 45;
 532   1        fenzi = speed;fenmu = circle;
 533   1      percent =  (fenzi/fenmu)*100;
 534   1      for (t=0;t<turningtime;t++) 
 535   1      {
 536   2          A1 = 0,A2 = 1,B1 = 1,B2 = 0,C1 = 0,C2 = 1,D1 = 1,D2 = 0;  
 537   2          pwmdelay(turningspeed);
 538   2          A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
 539   2          pwmdelay(circle-turningspeed);
 540   2      }
 541   1      }
 542          
 543          
 544          void xunji()
 545          {  
 546   1          if((lse1==0)&&(lse2==0)&&(lse3==1)&&(lse4==0))
 547   1          {
 548   2            flag = 0; //左边检测到黑线     
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 10  

 549   2          }
 550   1          
 551   1          else if((lse1==0)&&(lse2==0)&&(lse3==0)&&(lse4==1))
 552   1          {
 553   2          flag = 1;//左边检测到黑线
 554   2          }
 555   1          
 556   1          else if((lse1==0)&&(lse2==0)&&(lse3==1)&&(lse4==1))
 557   1          {
 558   2          flag = 2;//左边检测到黑线
 559   2          }
 560   1          
 561   1          else if((lse1==0)&&(lse2==1)&&(lse3==1)&&(lse4==1))
 562   1          {
 563   2          flag = 3;//左边检测到黑线
 564   2          }
 565   1          
 566   1          else if((lse1==0)&&(lse2==0)&&(lse3==0)&&(lse4==0))
 567   1          {
 568   2          flag = 4;//没有检测到黑线
 569   2          }
 570   1          
 571   1          else if((lse1==0)&&(lse2==1)&&(lse3==1)&&(lse4==0))
 572   1          {
 573   2          flag = 5;//中间检测到黑线
 574   2          }
 575   1          
 576   1          else if((lse1==0)&&(lse2==1)&&(lse3==0)&&(lse4==0))
 577   1          {
 578   2          flag = 6;//右边检测到黑线
 579   2          }
 580   1        
 581   1        else if((lse1==1)&&(lse2==0)&&(lse3==0)&&(lse4==0))
 582   1          {
 583   2          flag = 7;//右边检测到黑线
 584   2          }
 585   1        
 586   1        else if((lse1==1)&&(lse2==1)&&(lse3==0)&&(lse4==0))
 587   1          {
 588   2          flag = 8;//右边检测到黑线
 589   2          }
 590   1        
 591   1        else if((lse1==1)&&(lse2==1)&&(lse3==1)&&(lse4==0))
 592   1          {
 593   2          flag = 9;//右边检测到黑线
 594   2          }
 595   1        
 596   1          else
 597   1        {
 598   2            flag = 10;
 599   2        }
 600   1      
 601   1        
 602   1          switch(flag)
 603   1        {
 604   2          case 0:  rightrun();rightrun();rightrun();runtimes = 0;break;
 605   2          case 1:  rightrun();rightrun();rightrun();runtimes = 0;break;
 606   2          case 2:  rightrun();rightrun();runtimes = 0;break;
 607   2          case 3:  rightrun();rightrun();rightrun();runtimes = 0;break;
 608   2          case 4:  run();runtimes = runtimes + 1;break;
 609   2          case 5:  run();runtimes = runtimes + 1;break;
 610   2          case 6:  leftrun();leftrun();runtimes = 0;break;
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 11  

 611   2          case 7:  leftrun();leftrun();leftrun();runtimes = 0;break;
 612   2          case 8:  leftrun();leftrun();leftrun();runtimes = 0;break;
 613   2          case 9:  leftrun();leftrun();leftrun();runtimes = 0;break; 
 614   2          case 10: rightrun();rightrun();rightrun();leftrun();leftrun();leftrun();runtimes = 0;break;
 615   2          default: rightrun();rightrun();rightrun();leftrun();leftrun();leftrun();runtimes = 0;break;
 616   2        }
 617   1      }
 618          
 619           //以上为寻迹部分代码-------------------------------------------------------------------------------------
             -------------------------------------------- 
 620           
 621           //以下为wifi部分代码-------------------------------------------------------------------------------------
             --------------------------------------------
 622          
 623          void Com_Int(void) interrupt 4
 624          {
 625   1        uchar i;
 626   1        EA = 0;
 627   1        if(RI == 1) //当硬件接收到一个数据时，RI会置位
 628   1        {     
 629   2          RI = 0; 
 630   2          receive_data = SBUF;//接收到的数据  
 631   2          displaymode = 1;  //切换为遥控显示
 632   2      //    angle = 4.5;count =0;Delay80ms();//舵机角度调整为正向
 633   2          
 634   2         if(receive_data == '1'&&judgement == 2)                    //前进   
 635   2          {
 636   3            operate = 1;
 637   3          displaymode = 1 ; 
 638   3      for (t=0;t<wifisrunningtime;t++) 
 639   3      {
 640   4          A1 = 1,A2 = 0,B1 = 1,B2 = 0,C1 = 1,C2 = 0,D1 = 1,D2 = 0;  
 641   4          pwmdelay(wifispeed);
 642   4          A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
 643   4          pwmdelay(wificircle-wifispeed);
 644   4      }
 645   3      A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
 646   3      fenzi = wifispeed;fenmu = wificircle;
 647   3      percent =  (fenzi/fenmu)*100;
 648   3          }
 649   2      
 650   2      
 651   2         if(receive_data == '2'&&judgement == 2)                        //后退   
 652   2          {
 653   3            operate = 23;
 654   3            displaymode = 1;
 655   3      for (t=0;t<wifisrunningtime;t++) 
 656   3      {
 657   4          A1 = 0,A2 = 1,B1 = 0,B2 = 1,C1 = 0,C2 = 1,D1 = 0,D2 = 1;  
 658   4          pwmdelay(wifispeed);
 659   4          A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
 660   4          pwmdelay(wificircle-wifispeed);
 661   4      }
 662   3      A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
 663   3      fenzi = wifispeed;fenmu = wificircle;
 664   3      percent =  (fenzi/fenmu)*100;  
 665   3          }
 666   2        
 667   2      
 668   2          
 669   2         if(receive_data == '3'&&judgement == 2)                      //左拐
 670   2          {
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 12  

 671   3            operate = 45;
 672   3            displaymode = 1;
 673   3      for (t=0;t<wifiturningtime;t++) 
 674   3      {
 675   4          A1 = 0,A2 = 1,B1 = 1,B2 = 0,C1 = 0,C2 = 1,D1 = 1,D2 = 0;  
 676   4          pwmdelay(wifiturningspeed);
 677   4          A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
 678   4          pwmdelay(wificircle-wifiturningspeed);
 679   4      }
 680   3      A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
 681   3      fenzi = wifispeed;fenmu = wificircle;
 682   3      percent =  (fenzi/fenmu)*100;  
 683   3          }
 684   2      
 685   2          
 686   2         if(receive_data == '4'&&judgement == 2)                      //右拐                                  
 687   2          {
 688   3            operate = 67;
 689   3            displaymode = 1;
 690   3      for (t=0;t<wifiturningtime;t++) 
 691   3      {
 692   4          A1 = 1,A2 = 0,B1 = 0,B2 = 1,C1 = 1,C2 = 0,D1 = 0,D2 = 1;  
 693   4          pwmdelay(wifiturningspeed);
 694   4          A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
 695   4          pwmdelay(wificircle-wifiturningspeed);
 696   4      }
 697   3      A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
 698   3      fenzi = wifispeed;fenmu = wificircle;
 699   3      percent =  (fenzi/fenmu)*100;  
 700   3          }
 701   2      
 702   2         
 703   2      
 704   2      
 705   2         if(receive_data == '0')                        //停车退出避障
 706   2          {
 707   3            operate = 89;
 708   3            displaymode = 1;
 709   3            judgement = 2;
 710   3         A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0;
 711   3        percent =  0;
 712   3          }
 713   2      
 714   2        
 715   2         if (receive_data == 'u'&&judgement == 2)    //加速 
 716   2             {
 717   3           wifispeed =  wifispeed+200;
 718   3      fenzi = wifispeed;fenmu = wificircle;
 719   3      percent =  (fenzi/fenmu)*100;
 720   3      if (wifispeed < 600)     //WiFi模式速度控制 （防止速度过低无法启动） 
 721   3           {
 722   4         wifispeed = 600;
 723   4           }
 724   3           
 725   3      if (wifispeed > wificircle) //WiFi模式速度控制 （防止速度过高错误）
 726   3           {
 727   4         wifispeed = wificircle;
 728   4           }
 729   3             }
 730   2        
 731   2         if (receive_data == 'd'&&judgement == 2)    //减速 
 732   2             {
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 13  

 733   3           wifispeed =  wifispeed-200;
 734   3      fenzi = wifispeed;fenmu = wificircle;
 735   3      percent =  (fenzi/fenmu)*100;
 736   3      if (wifispeed < 600)     //WiFi模式速度控制 （防止速度过低无法启动） 
 737   3           {
 738   4         wifispeed = 600;
 739   4           }
 740   3           
 741   3      if (wifispeed > wificircle) //WiFi模式速度控制 （防止速度过高错误）
 742   3           {
 743   4         wifispeed = wificircle;
 744   4           }
 745   3             }
 746   2        
 747   2       
 748   2            if (receive_data == 'u'&&judgement == 1)        //避障加速 
 749   2                    {
 750   3                    bizhangspeed = bizhangspeed + 200;                
 751   3                      
 752   3      if (bizhangspeed < 800)     //寻迹模式速度控制 （防止速度过低无法启动） 
 753   3           {
 754   4         bizhangspeed = 800;
 755   4           }
 756   3           
 757   3      if (bizhangspeed > bizhangcircle) //寻迹模式速度控制 （防止速度过高错误）
 758   3           {
 759   4         bizhangspeed = bizhangcircle;
 760   4           }
 761   3                    }
 762   2                    
 763   2           if (receive_data == 'd'&&judgement == 1)        //避障减速
 764   2                    {
 765   3                    bizhangspeed = bizhangspeed - 200;
 766   3      if (bizhangspeed < 800)     //寻迹模式速度控制 （防止速度过低无法启动） 
 767   3           {
 768   4         bizhangspeed = 800;
 769   4           }
 770   3           
 771   3      if (bizhangspeed > bizhangcircle) //寻迹模式速度控制 （防止速度过高错误）
 772   3           {
 773   4         bizhangspeed = bizhangcircle;
 774   4           }
 775   3                    } 
 776   2             
 777   2             
 778   2         if (receive_data == 'e')    //切换为寻迹模式 
 779   2             {
 780   3              displaymode = 2; 
 781   3               runtimes = 0;
 782   3                  while(1)
 783   3                  {
 784   4        if(runtimes >= 5)
 785   4        {srunnningtime=35;}   
 786   4        
 787   4        if(runtimes <= 5)
 788   4        {srunnningtime=(0.000009722*speed*speed)-(0.03806*speed)+46.2;}  //此处为平衡车子转速的程序0.000009722222
             -222222223*speed*speed-0.03805555555555556*speed+46.22222222222222
 789   4        
 790   4             oleddisplay (displaymode);  //显示屏
 791   4                     detect ();
 792   4                    xunji() ;             //寻迹本体
 793   4                    
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 14  

 794   4              if (distance <= 20)        //保护程序     
 795   4              {
 796   5                displaymode = 1;
 797   5            A1 = 0,A2 = 1,B1 = 0,B2 = 1,C1 = 0,C2 = 1,D1 = 0,D2 = 1; 
 798   5            pwmdelay(speed*20);
 799   5            A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
 800   5                    break;}         
 801   4                    
 802   4      
 803   4                    
 804   4                    
 805   4            if(RI == 1) //当硬件接收到一个数据时，RI会置位
 806   4        {     
 807   5          RI = 0;
 808   5          receive_data = SBUF;//接收到的数据
 809   5          
 810   5          if (receive_data == '0')        //退出寻迹模式 
 811   5                    {
 812   6                         A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
 813   6                    break;
 814   6                    }   
 815   5              
 816   5        
 817   5           if (receive_data == 'u')    //寻迹加速 
 818   5             {
 819   6           speed =  speed+200;
 820   6      fenzi = speed;fenmu = circle;
 821   6      percent =  (fenzi/fenmu)*100;
 822   6       if (speed < 800)     //寻迹模式速度控制 （防止速度过低无法启动） 
 823   6           {
 824   7         speed = 800;
 825   7           }
 826   6           
 827   6      if (speed > circle) //寻迹模式速度控制 （防止速度过高错误）
 828   6           {
 829   7         speed = circle;
 830   7           }
 831   6             }
 832   5        
 833   5           if (receive_data == 'd')    //寻迹减速 
 834   5             {
 835   6           speed = speed-200;
 836   6      fenzi = speed;fenmu = circle;
 837   6      percent =  (fenzi/fenmu)*100;
 838   6      
 839   6       if (speed < 800)     //寻迹模式速度控制 （防止速度过低无法启动） 
 840   6           {
 841   7         speed = 800;
 842   7           }
 843   6           
 844   6      if (speed > circle) //寻迹模式速度控制 （防止速度过高错误）
 845   6           {
 846   7         speed = circle;
 847   7           }
 848   6             }      
 849   5        }           
 850   4                                
 851   4                  } 
 852   3              displaymode = 1;   //将显示转变为默认的遥控模式 
 853   3        
 854   3                }
 855   2        
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 15  

 856   2      
 857   2      
 858   2                
 859   2         if (receive_data == 'z')//进入避障模式------------------------------------------------------------------
             -----------
 860   2          { 
 861   3            displaymode = 3;    
 862   3      
 863   3        judgement = 1;
 864   3          }           
 865   2                    
 866   2             }
 867   1          
 868   1          for(i=0; i<36; i++)
 869   1          {
 870   2            SBUF = PuZh[i];   //将要发送的数据放入到发送寄存器
 871   2            while(!TI);       //等待发送数据完成
 872   2            TI=0;             //清除发送完成标志位
 873   2            Delay_1ms(1);
 874   2          }
 875   1      EA    = 1; 
 876   1      
 877   1      } 
 878              
 879          
 880          //以上为wifi模式部分代码----------------------------------------------------------------------------------
             --------------------------------------------
 881          
 882          
 883          //一下为避障部分代码--------------------------------------------------------------------------------------
             --------------------------------------------
 884          void Delay80ms()    //@11.0592MHz
 885          {
 886   1        unsigned char i, j, k;
 887   1      
 888   1        _nop_();
 889   1        _nop_();
 890   1        i = 9;
 891   1        j = 104;
 892   1        k = 139;
 893   1        do
 894   1        {
 895   2          do
 896   2          {
 897   3            while (--k);
 898   3          } while (--j);
 899   2        } while (--i);
 900   1      }
 901          
 902          void detect ()
 903          {
 904   1           Trig_P=0;  
 905   1        TMOD |= 0x01; 
 906   1        distance=GetDistance();
 907   1      }
 908           
 909          void duoji_Init()           
 910            {
 911   1        TL1 = 0;    //设置定时初值
 912   1        TH1 = 0;    //设置定时初值
 913   1        AUXR &= 0x7F;   //定时器时钟12T模式
 914   1        TMOD &= 0xF0;   //设置定时器模式
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 16  

 915   1        TL1 = 0xD2;   //设置定时初值
 916   1        TH1 = 0xFF;   //设置定时初值
 917   1        TF1 = 0;    //清除TF0标志
 918   1        TR1 = 1;    //定时器0开始计时
 919   1        EA=1;
 920   1        ET1 = 1;    
 921   1        }
 922            
 923          void duoji() interrupt 3 
 924          {
 925   1        TR1 = 0; 
 926   1        TL1 = 0xD7;   //设置定时初值
 927   1        TH1 = 0xFD;   //设置定时初值
 928   1      
 929   1        if(count <= angle) //5==0° 15==90°
 930   1        { 
 931   2          PWM = 1; 
 932   2        }
 933   1        else 
 934   1        { 
 935   2          PWM = 0; 
 936   2        }
 937   1        count = count + 0.5;
 938   1        if (count >= 200) //T = 20ms清零
 939   1        { 
 940   2          count = 0;
 941   2        }
 942   1        TR1 = 1; //开启T0
 943   1      }
 944          
 945          void judge ()
 946          {
 947   1      angle = 4.5;count =0;Delay80ms();
 948   1      detect ();//回正
 949   1      distance = distance;
 950   1      oleddisplay (displaymode);    
 951   1      
 952   1      angle = 1.5;count =0;Delay80ms();
 953   1      detect ();//右转头把数据赋给右边
 954   1      rightdistance = distance;
 955   1      oleddisplay (displaymode);
 956   1      
 957   1      angle = 4.5;count =0;Delay80ms();
 958   1      detect ();//回正
 959   1      distance = distance;
 960   1      oleddisplay (displaymode);    
 961   1      
 962   1      angle = 7.5;count =0;Delay80ms();
 963   1      detect ();//左转头把数据赋给左边
 964   1      leftdistance = distance;
 965   1      oleddisplay (displaymode);
 966   1      
 967   1      angle = 4.5;count =0;Delay80ms();
 968   1      detect ();//回正
 969   1      distance = distance;
 970   1      oleddisplay (displaymode);  
 971   1      
 972   1      
 973   1      }
 974          
 975          void bizhang ()
 976          { 
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 17  

 977   1        
 978   1      if (distance>18)
 979   1      {
 980   2        if(leftdistance>14 && rightdistance>14)
 981   2        {location = 0;}
 982   2        
 983   2        else if (leftdistance<15 && rightdistance<15)
 984   2        {location = 0;} 
 985   2        
 986   2        else if (leftdistance<15 && rightdistance>15)
 987   2        {location = 2;}
 988   2        
 989   2        else if (leftdistance>15 && rightdistance<15)
 990   2        {location = 3;}
 991   2      }
 992   1      
 993   1      if (distance<18)  
 994   1      {
 995   2      
 996   2      if (leftdistance<20 && rightdistance<20)  
 997   2      {location = 1;}
 998   2      
 999   2      else if (leftdistance>20 && rightdistance<20)
1000   2      {location = 3;} 
1001   2      
1002   2      else if (leftdistance<20 && rightdistance>20)
1003   2      {location = 2;}
1004   2      
1005   2      if (leftdistance>=20 && rightdistance>=20)
1006   2      {
1007   3      if (leftdistance > rightdistance)
1008   3      {location = 3;}
1009   3        
1010   3      if (leftdistance < rightdistance)
1011   3      {location = 2;} 
1012   3      }
1013   2      
1014   2      }
1015   1      
1016   1      switch (location)
1017   1      {
1018   2        case 0:   bizhangrun(); break;               //范围内无障碍
1019   2        case 1:   bizhangbackrun();break;            //范围内都是障碍
1020   2        case 2:   bizhangrightrun ();break;          //左边有障碍
1021   2        case 3:   bizhangleftrun  ();break;          //右边有障碍
1022   2      }
1023   1      
1024   1      }
1025          
1026          void bizhangrun ()
1027          {
1028   1            operate = 1;
1029   1        fenzi = bizhangspeed;fenmu = bizhangcircle;
1030   1      percent =  (fenzi/fenmu)*100;
1031   1      for (t=0;t<bizhangrunnningtime;t++) 
1032   1      {
1033   2          A1 = 1,A2 = 0,B1 = 1,B2 = 0,C1 = 1,C2 = 0,D1 = 1,D2 = 0;  
1034   2          pwmdelay(bizhangspeed);
1035   2          A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
1036   2          pwmdelay(bizhangcircle-bizhangspeed);
1037   2      }
1038   1      
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 18  

1039   1      
1040   1      }
1041          
1042          void bizhangbackrun ()
1043          {
1044   1            operate = 23;
1045   1        fenzi = bizhangspeed;fenmu = bizhangcircle;
1046   1      percent =  (fenzi/fenmu)*100;
1047   1      for (t=0;t<bizhangrunnningtime;t++) 
1048   1      {
1049   2          A1 = 0,A2 = 1,B1 = 0,B2 = 1,C1 = 0,C2 = 1,D1 = 0,D2 = 1;  
1050   2          pwmdelay(bizhangspeed);
1051   2          A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
1052   2          pwmdelay(bizhangcircle-bizhangspeed);
1053   2      }
1054   1      
1055   1      }
1056          
1057          void bizhangrightrun ()
1058          {
1059   1        operate = 67;
1060   1        fenzi = bizhangspeed;fenmu = bizhangcircle;
1061   1      percent =  (fenzi/fenmu)*100;
1062   1      for (t=0;t<bizhangturningtime;t++) 
1063   1      {
1064   2          A1 = 1,A2 = 0,B1 = 0,B2 = 1,C1 = 1,C2 = 0,D1 = 0,D2 = 1;  
1065   2          pwmdelay(bizhangturningspeed);
1066   2          A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
1067   2          pwmdelay(bizhangcircle-bizhangturningspeed);
1068   2      }
1069   1      
1070   1      }
1071          void bizhangleftrun ()
1072          {
1073   1        operate = 45;
1074   1        fenzi = bizhangspeed;fenmu = bizhangcircle;
1075   1      percent =  (fenzi/fenmu)*100;
1076   1      for (t=0;t<bizhangturningtime;t++) 
1077   1      {
1078   2          A1 = 0,A2 = 1,B1 = 1,B2 = 0,C1 = 0,C2 = 1,D1 = 1,D2 = 0;  
1079   2          pwmdelay(bizhangturningspeed);
1080   2          A1 = 0,A2 = 0,B1 = 0,B2 = 0,C1 = 0,C2 = 0,D1 = 0,D2 = 0; 
1081   2          pwmdelay(bizhangcircle-bizhangturningspeed);
1082   2      }
1083   1      
1084   1      }
1085          
1086          void DelayMs(unsigned int time)
1087          {
1088   1        unsigned int i,j;
1089   1        for(i=0;i<time;i++)
1090   1          for(j=0;j<112;j++);
1091   1      }
1092          
1093          void Delay_1ms(uint i)//1ms延时
1094          {
1095   1        uchar x,j;
1096   1        
1097   1        for(j=0;j<i;j++)
1098   1          for(x=0;x<=148;x++);
1099   1      }
1100          
C51 COMPILER V9.54   MAIN                                                                  05/22/2021 09:45:54 PAGE 19  

1101          void main()
1102          {
1103   1        duoji_Init();
1104   1        angle = 4.5;count =0;Delay80ms();//舵机角度调整为正向
1105   1      oled_initial();
1106   1      displaymode = 1;
1107   1      operate = 89;
1108   1        judgement = 2;
1109   1      while (1)
1110   1      {
1111   2          detect ();
1112   2          oleddisplay (displaymode);
1113   2         UsartConfiguration();
1114   2        
1115   2        if (judgement == 1)
1116   2        {
1117   3          while (1)
1118   3          {   
1119   4        judge (); 
1120   4      bizhang ();
1121   4        if (judgement == 2)
1122   4            { angle = 4.5;count =0;Delay80ms();break;}
1123   4          }
1124   3        }
1125   2        
1126   2        
1127   2       }
1128   1      }
1129          
1130          
1131           
1132           void UsartConfiguration()
1133          { 
1134   1        PCON &= 0x7F;   //波特率不倍速
1135   1        SCON = 0x50;    //8位数据,可变波特率
1136   1        AUXR &= 0xFB;   //独立波特率发生器时钟为Fosc/12,即12T
1137   1        BRT = 0xFD;   //设定独立波特率发生器重装值
1138   1        AUXR |= 0x01;   //串口1选择独立波特率发生器为波特率发生器
1139   1        AUXR |= 0x10;   //启动独立波特率发生器
1140   1        ES = 1;       //开串口中断
1141   1        EA = 1;       //开总中断
1142   1        
1143   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6259    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     91      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
